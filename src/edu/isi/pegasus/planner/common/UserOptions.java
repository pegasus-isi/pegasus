/**
 * Copyright 2007-2008 University Of Southern California
 *
 * <p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License at
 *
 * <p>http://www.apache.org/licenses/LICENSE-2.0
 *
 * <p>Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
package edu.isi.pegasus.planner.common;

import edu.isi.pegasus.common.logging.LogManager;
import edu.isi.pegasus.planner.classes.PlannerOptions;
import java.util.Collection;
import java.util.Set;

/**
 * A Singleton wrapper around the PlannerOptions class to get hold of the options specified by the
 * user to run Pegasus. This allows us to get hold of the options anywhere without us messing up
 * with the constructors of classes.
 *
 * @author Karan Vahi
 * @author Gaurang Mehta
 * @version $Revision$
 * @see org.griphyn.cPlanner.classes.PlannerOptions
 */
public class UserOptions {
    /** The object holding the Singleton instance. */
    private static UserOptions mPOptions = null;

    /** The Logger object used to log the messages. */
    private LogManager mLogger;

    /** The object containing all the user options. */
    private PlannerOptions mPlannerOpts = null;

    /**
     * The method used to invoke the singleton instance the first time, from the CPlanner class.
     *
     * @param opt the object containing the options to the Planner.
     */
    public static UserOptions getInstance(PlannerOptions opt) {
        if (mPOptions == null && opt != null) {
            mPOptions = new UserOptions(opt);
        }
        return mPOptions;
    }

    /** The method used to invoke the singleton instance from the other classes. */
    public static UserOptions getInstance() {
        return getInstance(null);
    }

    /**
     * The private constructor that initializes the user options. This should be invoked from the
     * CPlanner class in the toolkit package.
     *
     * @throws RuntimeException in case of incorrect initialization.
     */
    private UserOptions(PlannerOptions opt) {
        if (opt == null) {
            mLogger.log(
                    "Wrong Invocation of the Singleton Instance", LogManager.FATAL_MESSAGE_LEVEL);
            throw new RuntimeException("Wrong Invocation of the Singleton Instance");
        }
        mPlannerOpts = opt;
    }

    /**
     * Returns the dax file, that was generated by Chimera containing the description of the
     * Abstract plan.
     */
    public String getDaxFile() {
        return this.mPlannerOpts.getDAX();
    }

    /** Returns output pool where the user wants the data products to be transferred to. */
    public String getOutputPool() {
        return this.mPlannerOpts.getOutputSite();
    }

    /**
     * Returns the options passed to the planner.
     *
     * @return PlannerOptions
     */
    public PlannerOptions getOptions() {
        return this.mPlannerOpts;
    }

    /** Returns the directory where the user wants the submit files to be generated. */
    public String getSubmitFileDir() {
        return this.mPlannerOpts.getSubmitDirectory();
    }

    /**
     * Returns the list of execution pools where the user wants the data products to be computed.
     */
    public Collection getExecutionSites() {
        // return new Vector(this.mPlannerOpts.getExecutionSites());
        return this.mPlannerOpts.getExecutionSites();
    }

    /**
     * Sets the execution sites.
     *
     * @param sites the <code>Set</code> containing the site names.
     */
    public void setExecutionSites(Collection sites) {
        this.mPlannerOpts.setExecutionSites(sites);
    }

    /** Returns whether we want to create a Random Directory or not. */
    public boolean generateRandomDirectory() {
        return this.mPlannerOpts.generateRandomDirectory();
    }

    /** It returns the set of cache files. */
    public Set getCacheFiles() {
        return this.mPlannerOpts.getCacheFiles();
    }
    /**
     * Returns the name of the random directory, only if the generate Random Dir flag is set. Else
     * it returns null.
     */
    public String getRandomDirName() {
        if (this.generateRandomDirectory()) {
            return this.mPlannerOpts.getRandomDir();
        }
        return null;
    }

    /** Returns true if the user had asked for the force option. */
    public boolean getForceOption() {
        return this.mPlannerOpts.getForce();
    }
}
