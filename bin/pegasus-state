#!/usr/bin/env perl
#
# collect information about workflows and display their states.
#
##
#  Copyright 2007-2010 University Of Southern California
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing,
#  software distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
##
#
# Author: Jens-S. Vöckler voeckler at isi dot edu
# Revision: $Revision$
#
use v5.8.8;			# unbroken unicode requires perl >= 5.8.8
use strict; 

BEGIN {
    # use very early - before loading most modules!
    $main::isutf8 = ( exists $ENV{LANG} && $ENV{LANG} =~ m{utf-?8}i );
    delete $ENV{LANG};
    $ENV{LANG} = 'C';
}

use utf8; 			# tell Perl "this script contains UTF-8"
use Carp; 
use Cwd qw(getcwd abs_path); 
use File::Spec;
use File::Basename qw(basename dirname); 
use Getopt::Long qw(:config bundling no_ignore_case);
use Data::Dumper; 

# path to load our libs..
BEGIN {
    require File::Spec->catfile( dirname($0), 'common.pm' );
    common->import(':all');
}
use Pegasus::Common;
use Pegasus::Properties qw(%initial); # parses -Dprop=val from @ARGV

# set function TIOCGWINSZ to return ioctl() argument
if ( $^O eq 'darwin' ) { 
    # h2ph is broken on Darwin
    *TIOCGWINSZ = sub { 0x40087468; };
} else {
    eval { require "sys/ioctl.ph" }; 
}

#
# --- globals ----------------------------------------------
#
$main::debug = 0;		# debug output
$main::user = $ENV{USER} || $ENV{LOGNAME} || scalar getpwuid($>);
$_ = '$Revision$';     # don't edit, automatically updated by CVS
$main::revision=$1 if /Revision:\s+([0-9.]+)/o;
$main::onatty = -t STDOUT; 	# are we connected to a terminal?
$main::dirsep = File::Spec->catdir( '', '' ); 
$main::space = '  ';		# 2 spaces in basic mode
@main::clong = 			# Condor job states (basic mode)
    ( 'Unsub'			# U
    , 'Idle'			# I
    , 'Run'			# R
    , 'Del'			# X
    , 'Done'			# C
    , 'Held'			# H
    ); 
@main::cstat = qw(U I R X C H);	# Condor job states (expert mode)
@main::ccolor = 
    ( "\033[0;37m"		# unsubmitted (gray)
    , "\033[0;34m"		# idle (blue)
    , "\033[0;32m"		# running (green)
    , "\033[0;35m"		# removing (magenta)
    , "\033[0;36m"		# completed (cyan)
    , "\033[0;31m"		# held (red)
    );
$main::bold  = "\033[1m";	# start real xterm as "xterm -bdc"
$main::reset = "\033[0m";	# reset all color/bold/etc.
%main::ccolor = map { $main::cstat[$_] => $main::ccolor[$_] } 0 .. $#main::cstat;
@main::dstat = qw(? I R S F);	# Workflow states
@main::dcolor =
    ( "\033[0;37m"		# unknown (gray)
    , "\033[0;36m"		# indeterminable (cyan)
    , "\033[0;34m"		# running (blue)
    , "\033[0;30m"		# success (black)
    , "\033[0;31m"		# failure (red)
    );
%main::gstat = 			# Globus job states (expert mode)
    (   0 => '?'		# unknown
    ,   1 => 'P'                # pending
    ,   2 => 'A'                # active
    ,   4 => 'F'                # failed 
    ,   8 => 'D'                # done
    ,  16 => 'S'                # suspend
    ,  32 => 'U'                # unsuspend
    ,  64 => 'I'                # stage-in
    , 128 => 'O'                # stage-out
    );
@main::jobclass = 
    ( 'unknown'
    , 'compute'
    , 'stage-in'
    , 'stage-out'
    , 'register'
    , 'xsite-xfer'
    , 'createdir'
    , 's-compute'		# deprecated
    , 'clean-up'
    , 'chmod'
    , 'dax'
    , 'dag'
    );
@main::jobshort =		# short job class (job type)
    (   '-', 'job',  'si',  'so'
    ,  'rr', 'isx',  'cd', 'stc'
    , 'clu', 'chm', 'dax', 'dag' ); 
$main::time = $^T;		# initialization only 
%main::dagman_p =		# predicate to determine variations on DAGMan
    map { $_ => 1 } qw(pegasus-dagman condor_dagman); 
%main::width = 			# width selection (0=unlimited)
    ( dagnodename => 30		# width of concrete dag node identifiers
    , pegasus_wf_name => 24	# width of abstract workflow identifiers
    , cmd => 20			# width of executable that is actually run
    );
$main::cache = undef;		# debug 
my ($rows,$cols) = &initialize_winch;

# %title describes any head we would want to show, 
# indexed by a short internal key:
# {header} is what to put into the title of the output
# {function} is an fptr, being called with current row (q) job classads
# {minwidth} is an minimal width, with negative width meaning left adjustment
# {legend} is what to display for this column in the legend
#
my %title =
    ( 'STAT' => { header => 'STAT'
		, function => \&x_jobstatus
		, minwidth => -4
		, legend => 'Condor job status'
		},
      'S' => { header => 'S'
	     , function => \&x_cstat
	     , minwidth => 1
	     , legend => 'Condor job status'
	     },
      'IN_STATE' => { header => 'IN_STATE'
		    , function => \&x_in_state
		    , minwidth => 8
		    , legend => 'Time job spent in current Condor status'
                    },
      'JPRIO' => { header => 'PRI'
		 , minwidth => 3
		 , function => \&x_jobpriority
		 , legend => 'Condor job priority'
	         },
      'PJC' => { header => 'CLASS'
	       , minwidth => -5
	       , function => \&x_pegasus_jobtype
	       , legend => 'Pegasus job type'
	       },
      'PJCN' => { header => 'C'
	        , minwidth => 1
	        , function => \&x_pegasus_jobtypenum
	        , legend => 'Pegasus job type'
	       },
      'PJCS' => { header => 'PJC'
	        , minwidth => -3
	        , function => \&x_pegasus_jobtypeshort
	        , legend => 'Pegasus job type'
	       },
      'JOB1' => { header => 'JOB'
	        , minwidth => -50
	        , function => \&x_job1
		, legend => 'Workflow- or DAG-Node ID'
                },
      'JOB2' => { header => 'JOB'
	        , minwidth => -32
	        , function => \&x_job2
		, legend => 'DAG-Node ID, command, and workflow-ID'
                },
      'CONDORID' => { header => 'ID'
		    , minwidth => 2
		    , function => \&x_condorid
		    , legend => 'Condor cluster ID'
		    },
      'SITE' => { header => 'SITE'
		, minwidth => -5
		, function => \&x_site
		, legend => 'Job site'
                },
      'C/G' => { header => 'C/G'
	       , function => \&x_cgstatus
	       , minwidth => 3
	       , legend => 'Condor- and Globus job status'
	       }
    );

# @main::title is an array of default outputs, indexed by 'expert
# level'. Each entry is a key into %title. (Eventually, this can
# be overwritten by a CLI option for your own mix-n-match (TBD).)
@main::title = 
    ( 
       # first level is the novice state, leave out distractive information
       [qw(STAT IN_STATE JOB1) ],

       # some more complex information in first expert level 
       [qw(CONDORID S IN_STATE JPRIO JOB2) ],

       # even more complex information in next expert level 
       [qw(CONDORID C/G IN_STATE JPRIO PJCS SITE JOB2) ]
    );

#
# --- functions --------------------------------------------
#
sub usage(;$) {
    my $msg = shift;
    my $flag = defined $msg && lc($msg) ne 'help';
    if ( $flag ) {
	print "\033[1m" if $main::onatty;
	print "ERROR: $msg\n";
	print "\033[0m" if $main::onatty; 
    }

    my $app = basename($0); 
    print << "EOF";

Usage: $app [options ] [dagdir]
 $app helps monitor your jobs by querying Condor.

Optional arguments:
 -h|--help        print this help and exit.
 -V|--version     print version information and exit. 
 -v|--verbose     increase expert level.
 -d|--debug       increase debug level.
 -u|--user name   monitor for user 'name', default is $main::user.
 -w|--watch [s]   repeatedly print output every 's' seconds, default TBD.
 -i|--idle        DO NOT display any jobs in state 'idle'. 
 --[no]legend     Disable or enable showing of the legend, default on. 
 --[no]held       Disable or enable showing HoldReason, default on.
 --[no]heavy      Disable or enable heavy lines in Unicode output, default off. 

 rundir           directory to monitor, default is CWD. [currently unused]

EOF
    exit ($flag ? 1 : 0); 
}

sub myversion() {
    my $version = version();
    print "Pegasus $version, @{[basename($0)]} $main::revision\n"; 
    exit 0; 
}

sub trim($) { 
    # purpose: remove leading and trailing whitespace, quotes around
    # paramtr: $s (IN): a string
    # returns: possibly shortened string
    #
    my $s = shift;
    $s =~ s/^\s+//;
    $s =~ s/\s+$//;
    $s = substr($s,1,-1) if substr($s,0,1) =~ /[""'']/;
    $s; 
}

sub commas($) {
    # purpose: put commas to separate engineering dimensions
    # paramtr: $x (IN): numerical string
    # returns: string with commas inserted as necessary
    # warning: assumes english locale
    #
    my $text = reverse shift();
    $text =~ s/(\d{3})(?=\d)(?!\d*\.)/$1,/g;
    return scalar reverse $text;
}

sub plural($$) {
    # purpose: print number space item. Add plural-s if number != 1
    # paramtr: $n (IN): count
    #          $s (IN): item string
    # returns: constructed string with proper plural
    #
    my $n = shift;
    my $s = shift;
    return "$n $s" if $n == 1;

    if ( substr($s,-1) eq 'y' ) {
        commas($n) . ' ' . substr($s,0,-1) . 'ies';
    } else {
        commas($n) . " ${s}s";
    }
}

sub initialize_winch {
    # purpose: determine rows and columns of current window
    # returns: ($rows,$cols)
    # warning: Make sure that this function stays POSIX signal safe!
    #
    my $r = $ENV{LINES} || 25; 
    my $c = $ENV{COLUMNS} || 80; 

    if ( $main::onatty ) { 
	my $ws = pack('S!4',()); 
	if ( defined &TIOCGWINSZ && ioctl( STDOUT, &TIOCGWINSZ, $ws ) ) { 
	    ($r,$c) = unpack("S!4",$ws);
	}
    } else {
	$r = $c = 1E10;	# virtually unlimited
    }

    ($r,$c); 
}

sub sigwinch {
    # purpose: adjust global $rows and $cols when window size changes
    # globals: $rows (OUT): new row count
    #          $cols (OUT): new column count
    # warning: Make sure that this function stays POSIX signal safe!
    # warning: Make sure the handler is only installed for ttys!
    #
    my $ws = pack('S!4',()); 
    if ( defined &TIOCGWINSZ && ioctl( STDOUT, &TIOCGWINSZ, $ws ) ) { 
	($rows,$cols) = unpack("S!4",$ws);
    }
}

sub interval($) {
    # purpose: convert a number of seconds into days, hours, mins, secs
    # paramtr: $s (IN): total number of seconds
    # returns: formatted string with or without days
    #
    use integer;
    my $total = int( shift() );
    my $s = $total % 60;
    my $m = ($total % 3600) / 60; 

    if ( $total < 3600 ) { 
	# no days or hours
	sprintf "%02d:%02d", $m, $s;
    } elsif ( $total < 86400 ) { 
	# no days, don't show days
	sprintf "%02d:%02d:%02d", ($total / 3600), $m, $s;
    } else {
	my $h = ($total % 86400) / 3600;
	my $d = $total / 86400; 
	sprintf "%d+%02d:%02d:%02d", $d, $h, $m, $s;
    }
}

sub fit($$) {
    # purpose: fit a string into a given width, truncate start or end
    # paramtr: $width (IN): maximum space
    #          $s (IN): input string to format
    # returns: formatted string
    # 
    my $width = shift; 
    my $s = shift;
    my $len = length($s); 

    if ( $width != 0 && $len > abs($width) ) {
	if ( $width < 0 ) {
	    # fit from back
	    '..' . substr($s,($len+$width)+2);
	} else {
	    # forward fit
	    substr($s,0,$width-2) . '..';
	}
    } else {
	$s;
    }
}

sub cfit($$) {
    # purpose: fit a string into a given width, truncate center
    # paramtr: $width (IN): maximum space
    #          $s (IN): string to fit
    # returns: fitted string
    #
    my $width = abs( shift() );
    my $s = shift;
    my $len = length($s); 

    if ( $width == 0 || $len <= $width ) {
	# string fits
	$s;
    } else {
	use integer; 
	my $diff = $len - $width + 2; 
	substr( $s, 0, ($len-$diff)/2 ) . 
	    '..' .
	    substr( $s, ($len+$diff)/2 ); 
    }
}

sub kickstart($) {
    # purpose: remove kickstart arguments from commandline
    # paramtr: job classad 'Arguments' value
    # returns: remaining commandline, with kickstart removed
    # warning: also applies 'basename' to all absolute filenames
    #
    my @arg = split /\s+/, shift(); # FIXME: deal with quoting properly!
    my @result = ();
    my $state = 0;
    for ( my $i=0; $i<@arg; ++$i ) {
	if ( $state == 0 ) {
	    if ( substr($arg[$i],0,1) eq '-' ) {
		my $opt = substr($arg[$i],1,1);
		if ( index('ioelnNRBLTIwWSs',$opt) >= 0 ) {
		    # skip argument
		    ++$i;
		} elsif ( index('HVX',$opt) >= 0 ) {
		    # do nothing
		} else {
		    warn "Warning: Unknown kickstart argument $arg[$i]\n";
		}
	    } else {
		# this better be the application that we are starting
		$state = 1;
		push( @result, basename($arg[$i]) );
	    }
	} else {
	    # we can only apply basename to absolute filenames, because
	    # those are the only element we can recognize as such. 
	    if ( substr($arg[$i],0,1) eq $main::dirsep ) {
		push( @result, basename($arg[$i]) );
	    } else {
		push( @result, $arg[$i] );
	    }
	}
    }

    wantarray ? @result : join( ' ', @result );
}

sub seqexec(\%) {
    # purpose: count number of jobs in seqexec input file
    # paramtr: %r (IN): job class ad representation
    # returns: number of seqexec sub-jobs
    #
    my $r = shift;
    my $result = 0;

    my $fn = File::Spec->rel2abs( $r->{in}, $r->{iwd} );
    if ( open( S, "<$fn" ) ) {
	my @ok = ();
	while ( <S> ) {
	    s/[ \r\n]+$//;
	    s/\#.*//;
	    next if length($_) < 3;
	    push( @ok, $_ );
	}
	close S;
	$result = @ok+0;
    } else {
	warn "Warning: open $fn: $!, skipping\n"
	    if $main::debug > 3; 
    }

    $result;
}

sub cstat($) {
    # purpose: parse condor job state into string.
    # paramtr: $s (IN): job classad 'JobStatus'
    # returns: string representing Condor job state
    #
    my $s = shift;
    $s < @main::cstat ? $main::cstat[$s] : "$s";
}

sub gstat($) { 
    # purpose: parse condor job globus state into string.
    # paramtr: $s (IN): job classad 'GlobusStatus' (may be undef)
    # returns: string representing Globus job state
    #
    my $s = shift;
    if ( defined $s ) { 
	exists $main::gstat{$s} ? $main::gstat{$s} : "$s";
    } else {
	'-';
    }
}

sub parsersl($) { 
    # purpose: Parse a Globus RSL string into hash
    # paramtr: $rsl (IN): RSL string
    # returns: hash representing RSL values
    # warning: all keys will be canonicalized
    #
    my %result = (); 
    local $_ = shift; 
    while ( /\(([^)]+)\)/g ) {
        my ($k,$v) = split /=/, $1, 2;
	$k =~ s/[-_]//g;
	$result{lc $k} = $v;
    }
    %result;
}

sub condor_q(\%\%\@;%) {
    # purpose: Parse entire Condor-Q into hash of job classad hashes
    # paramtr: %jobs (OUT): parsed job classads indexed by 'clusterid'
    #          %dags (OUT): maps dagmanjobid to array of clusterids
    #          @t    (IN): ask condor_q only for these keys 
    #          %flag (IN): key value pairs controlling behavior
    # globals: $main::user (IN): which user to limit output to
    #          %main::title (IN): determines which keys to ask for
    #
    my $jobref = shift;
    my $dagref = shift;
    my $t      = shift; 
    my %flags = ( @_ ); 

    local(*Q);
    my $condor_q = find_exec('condor_q') ||
	die "FATAL: Unable to find 'condor_q' in your PATH.\n"; 

    if ( defined $main::cache && $main::cache ) { 
	# see --cache flag -- THIS IS ONLY FOR DEBUGGING
	open( Q, $main::cache ) || die "open $main::cache: $!\n"; 
    } else {
	# FIXME: 'condor_q' is expensive. Find better restrictions!
	open( Q, "$condor_q -l $main::user|" ) ||
	    die "FATAL: Unable to execute $condor_q: $!\n"; 
    }

    # skip intro
    while ( <Q> ) { 
	last if /^--/;
    }

    my (%db,@x);
    while ( <Q> ) { 
	s/[\r\n]+$//; 		# safe chomp
	if ( length($_) > 2 ) { 
	    # regular job classad
	    @x = split /\s+=\s+/, $_, 2;
	    die "this must not happen!" if exists $db{lc($x[0])}; 
	    $db{lc($x[0])} = trim($x[1]); 
	} else {
	    my $id = $db{clusterid}; 

	    # extra sanity?
	    die "nothing in queue?" unless scalar keys %db; 
	    die "nothing in cluster" unless defined $id; 

	    # noidle for Mats
	    unless ( $flags{noidle} && $db{jobstatus} == 1 ) {
		# add parsed job classads to %job
		$jobref->{$id} = { %db }; 

		# Add job belonging to a dagman to %dag
		# A dagman job will always be started prior to the job
		# it starts, thus the (condor) job for the DAGMan exists
		# for alive DAGMans.
		if ( exists $db{dagmanjobid} && exists $jobref->{ $db{dagmanjobid} } ) {
		    push( @{ $dagref->{ $db{dagmanjobid} } }, $id );
		} else {
		    # we need this branch for Condor jobs not managed by
		    # DAGMan, or for Condor jobs whose parent DAGMan died.
		    $dagref->{$id} = [] unless exists $dagref->{$id}; 
		}
	    }

	    # bookeeping
	    if ( exists $flags{count} ) {
		$flags{count}{condor}{ $db{jobstatus} }++;
		$flags{count}{all}{condor}++;
		if ( exists $db{globusstatus} ) {
		    $flags{count}{globus}{ $db{globusstatus} }++;
		    $flags{count}{all}{globus}++;
		}
	    }

	    # prepare for next round
	    %db = (); 
	}
    }

    # extra sanity? 
    die "hmm, maybe condor_q output formatting changed?" if scalar keys %db;

    close Q;
    if ( $main::debug ) { 
	warn "Warning: condor_q returned ", parse_exit($?), "\n" if $?; 
    }
}

sub find_leaves(\%) {
    # purpose: determine which are the top-level jobs to show
    # paramtr: %dag (IN): dag dependencies
    # returns: hash of leave jobs in queue
    #
    my $dagref = shift; 

    # find children and parents that are dags
    my (%parent,%leaves);
    foreach my $d ( keys %{$dagref} ) {
	foreach my $v ( @{$dagref->{$d}} ) {
	    $parent{$v}{$d} = 1	if exists $dagref->{$v};
	}
    }

    # find leaves
    my @fifo = keys %{$dagref};
    while ( @fifo ) {
	my $d = pop(@fifo);
	if ( exists $parent{$d} ) {
	    push( @fifo, keys %{$parent{$d}} );
	} else {
	    $leaves{$d} = 1;
	}
    }

    %leaves; 
}

sub assemble_job($;$) {
    # purpose: create the data columns for a given job
    # paramtr: $r (IN): job classad hashref
    #          $indent (IN): what to use for indentation 
    # returns: updated job classad hashref
    #
    my $r = shift; 		# job classad
    my $indent = shift || ''; 

    # extra sanity?
    confess "no job?" unless scalar keys %{$r}; 
    $r->{_indent} = $indent; 

    $r;
}

sub assemble_dag($$$;$);		# { } 
sub assemble_dag($$$;$) {
    # purpose: create the data rows for a given dag job
    # paramtr: %job (IN): see condor_q
    #          %dag (IN): see condor_q
    #          $dagid (IN): which workflow to assemble
    #          $indent (IN): what to use for indentation 
    # returns: ordered list (rows) of job classad refs (cols)
    # 
    my $jobref = shift;
    my $dagref = shift;
    my $dagid = shift;
    my $indent = shift || ''; 
    my @result = (); 

    # show dagman itself
    push( @result, assemble_job( $jobref->{$dagid}, $indent ) ); 
    delete $main::seen{$dagid}; 

    # show dependent jobs for dagman
    $indent = $main::graph[2] x ( length($indent) / length($main::graph[0]) );
    my @x = sort { $a <=> $b } @{ $dagref->{$dagid} }; 
    for ( my $j=0; $j < @x; ++$j ) { 
	# extra sanity? 
	die "unknown job" unless scalar keys %{$jobref->{$x[$j]}}; 

	my $conn = $main::graph[ $j == $#x ];
	if ( exists $dagref->{$x[$j]} ) {
	    push( @result, assemble_dag( $jobref, $dagref, $x[$j], "$indent$conn" ) ); 
	} else {
	    push( @result, assemble_job( $jobref->{$x[$j]}, "$indent$conn" ) ); 
	}
	delete $main::seen{$x[$j]}; 
    }

    @result; 
}

sub x_site {
    my $row = shift;
    $row->{'pegasus_site'} || '-';
}

sub x_pegasus_jobtype {
    my $row = shift;
    my $c = $row->{'pegasus_job_class'} + 0;
    $c < @main::jobclass ? $main::jobclass[$c] : "$c";
}

sub x_pegasus_jobtypeshort {
    my $row = shift;
    my $c = $row->{'pegasus_job_class'} + 0;
    $c < @main::jobshort ? $main::jobshort[$c] : "$c";
}

sub x_pegasus_jobtypenum {
    my $row = shift; 
    $row->{'pegasus_job_class'} || '-'; 
} 

sub x_in_state {
    my $row = shift;
    interval( $main::time - $row->{enteredcurrentstatus} );
}

sub x_jobpriority {
    my $row = shift;
    $row->{jobprio};
}

sub x_jobstatus {
    my $row = shift;
    my $s = $row->{jobstatus};
    $s < @main::clong ? $main::clong[$s] : "$s"; 
}

sub x_cstat {
    my $row = shift;
    cstat( $row->{jobstatus} );
}

sub x_cgstatus {
    my $row = shift; 
    cstat( $row->{jobstatus} ) . '/' . gstat( $row->{globusstatus} );
}

sub x_condorid {
    my $row = shift;
    $row->{clusterid}; 
}

sub x_job1 {
    my $row = shift; 
    my $result = ''; 

    if ( exists $row->{dagnodename} ) {
	$result = $row->{dagnodename};
    } elsif ( exists $row->{'pegasus_wf_name'} ) {
	$result = $row->{'pegasus_wf_name'};
    } else {
	my $cmd = basename( $row->{cmd} || '' );
	if ( $cmd eq 'kickstart' ) {
	    my @x = kickstart($row->{arguments});
	    $result = '*' . $x[0];
	} else {
	    $result = $cmd; 
	}
    }

    if ( $main::onatty ) { 
	"\033[0;37m" . $row->{_indent} . $main::ccolor[ $row->{jobstatus} ] . 
	    $result;
    } else {
	$row->{_indent} . $result;
    }
}

sub x_job2 {
    my $row = shift; 
    my $result = ''; 

    # show dagnodename first
    if ( exists $row->{dagnodename} ) { 
	$result .= cfit( $main::width{dagnodename}, 
			 $row->{dagnodename} );
    } elsif ( exists $row->{'pegasus_wf_name'} ) {
	$result .= cfit( $main::width{'pegasus_wf_name'}, 
			 $row->{'pegasus_wf_name'} );
    }

    # replace commandline ('cmd' and 'arguments')
    my $cmd = basename( $row->{cmd} || '' );

    if ( $cmd eq 'kickstart' ) { 
	$cmd = (kickstart($row->{arguments}))[0]; 
	$result .= ' [*' . cfit( $main::width{cmd}, $cmd ) . ']';
    } else {
	$result .= ' [' . cfit( $main::width{cmd}, $cmd ); 
	if ( exists $row->{'pegasus_cluster_size'} ) {
	    my $n = $row->{'pegasus_cluster_size'} + 0; 
	    if ( $cmd eq 'seqexec' || $n > 1 ) { 
		$result .= ": $n";
	    }
	}
	$result .= ']'; 
    }

    if ( $main::onatty ) { 
	"\033[0;37m" . $row->{_indent} . $main::ccolor[ $row->{jobstatus} ] . 
	    $result;
    } else {
	$row->{_indent} . $result;
    }
}

sub whittle_down(\@\@) {
    # purpose: taken a full queue and reduce to only columns that we'll show
    # paramtr: @title (IN): which expert level of @title
    #          @q (IN): array of job classads as hashes
    # globals: %title (IN): find the function pointer to create column
    # returns: array of columns to show for the given job row
    #
    my $t = shift;
    my $q = shift;
    my @result = (); 

    for my $row ( @{$q} ) {
	my @y = (); 		# all columns go into @y
	foreach my $k ( @{$t} ) { 
	    push( @y, &{$title{$k}{function}}( $row ) );
	}
	push( @result, [ @y ] ); # a row goes into @result
    }

    @result; 
}

sub signum($) { 
    # purpose: signum function
    # paramtr: $x (IN) number
    # returns: -1 for negative $x, +1 for positive $x and 0 for $x==0
    #
    my $x = shift; 
    ( $x < 0 ? -1 : ( $x > 0 ? 1 : 0 ) );
}

sub column_widths(\@\@) {
    # purpose: compute width of output column from data requirements
    # paramtr: @title (IN): which expert level of @title
    #          @q (IN): array of job classads as hashes
    # globals: %title (IN): minimum column width 
    #          $main::space (IN): current column spacing
    # returns: array of column width. 
    # warning: The last column is adjust to the screen width
    #
    my $t = shift;		# @title[expert] ref
    my $q = shift; 		# array of hash ref
    my @max = ();
    my @sgn = (); 

    # start with title minimum width
    foreach my $k ( @{$t} ) { 
	my $x = $title{$k}{minwidth};
	push( @max, abs($x) );
	push( @sgn, signum($x) ); 
    }

    # determine the width of each column, but no smaller than the title width
    foreach my $row ( @{$q} ) {
	for ( my $i=0; $i < @{$row}; ++$i ) { 
	    my $len = length( $row->[$i] ); 
	    $max[$i] = $len if $len > $max[$i]; 
	}
    }

    # fix last column to match maximum terminal width
    my $s = 0; 
    my $l = length( $main::space ); 
    for ( my $i=0; $i < @max; ++$i ) {
	$s += $max[$i] + $l; 
    }
    if ( $s > $cols ) {
	$s -= $max[$#max];
	$max[$#max] = $cols - $s;
	$max[$#max] = 0 if $max[$#max] < 0; 
    }

    # return results
    map { $max[$_] * $sgn[$_] } 0 .. $#max;
}

sub print_qlegend($\@) {
    # purpose: show the legend for condor-q output
    # paramtr: $cursor (IN): current row of output
    #          @title (IN): select expert level columns
    # globals: %title (IN): legend
    #          $main::bold (IN): turn on bold
    #          $main::reset (IN): turn off bold 
    # returns: new $cursor position
    #
    my $cursor = shift;
    my $t = shift;		# @title ref

    my $p = 0;
    for ( my $i=0; $i<@{$t}; ++$i ) { 
	my $k = $title{ $t->[$i] }{header};
	my $v = $title{ $t->[$i] }{legend}; 
	my $l = length($k) + length($v); 
	my $s = '';
	$s .= $main::bold if $main::onatty;
	$s .= $k;
	$s .= $main::reset if $main::onatty; 
	$s .= ': ' . $v; 
	if ( $p + $l + 2 > $cols ) { 
	    print "\n$s";
	    ++$cursor;
	    $p = $l + 2;
	} else {
	    print ' ' if $i; 
	    print $s; 
	    $p += $l + 3; 
	}
    }
    print "\n\n";
    $cursor += 2; 
}

sub print_qdebug($$$\%) {
    # purpose: show job classads of certain matches for current job
    # paramtr: $cursor (IN): current row
    #          $reserve (IN): how much space to reserve
    #          $watch (IN): are we in watch mode? 
    #          %q[i] (IN): current job class ads
    # globals: $main::onatty (IN): are we on a tty (can color)? 
    #          $cols (IN): current terminal width
    #          $rows (IN): current terminal height
    # returns: new cursor position
    #
    my $cursor = shift; 	# current row
    my $reserve = shift;	# current $reserve
    my $watch = shift; 		# current $watch
    my $qi = shift;		# $q[$i] ref

    my $m = $main::debug == 1 ? 
	qr{^(?:pegasus|wf)_} :
	qr{^(?:(?:pegasus|wf)_|job|globus)} ;

    my $p = $cols + $cols; 
    my ($s); 
    foreach my $k ( sort keys %{$qi} ) {
	if ( $watch && $cursor > $rows-$reserve-1 ) {
	    print " ..";
	    last; 
	}

	if ( $k =~ /$m/o ) { 
	    my $v = $qi->{$k}; 
	    my $l = length($k) + length($v); 
	    $s = '';
	    $s .= "\033[1;30m" if $main::onatty;
	    $s .= $k;
	    $s .= $main::reset if $main::onatty; 
	    $s .= '=' . $v; 
	    if ( $p+$l+2 > $cols ) { 
		print "\n\t$s"; 
		++$cursor;
		$p = $l+9; 
	    } else {
		print " $s";
		$p += $l+2;
	    }
	}
    }

    $cursor;
}

sub print_qsummary($\%) {
    # purpose: print summary line adding stats of Condor and Condor-G
    # paramtr: $cursor (IN): current row
    #          %count (IN): queue statistics
    # globals: $main::onatty (IN): are we on a tty (can color)? 
    #          @main::ccolor (IN): color settings
    #          $main::reset (IN): undo colorings
    # returns: new cursor position
    #
    my $cursor = shift;		# current row
    my $cref = shift;		# %count ref

    # create Condor job summary
    print "Queue summary: ", plural($cref->{all}{condor},'job'), " total"; 

    my $f = 0;
    foreach my $c ( sort { $a <=> $b } keys %{$cref->{condor}} ) {
	print( $f++ ? ' ' : ' (' );
	print $main::ccolor[$c] if $main::onatty; 
	print $main::cstat[$c], ':', commas($cref->{condor}{$c}); 
	print $main::reset if $main::onatty; 
    }
    print ')' if $f; 

    # Globus job summary
    if ( $cref->{all}{globus} > 0 ) { 
	print ", ", plural( $cref->{all}{globus}, 'Condor-G job' );
	$f = 0; 
	foreach my $g ( sort { $a <=> $b } keys %{$cref->{globus}} ) { 
	    print( $f++ ? ' ' : ' (' );
	    print $main::gstat{$g}, ':', commas($cref->{globus}{$g});
	}
	print ')' if $f;
    }

    print "\n"; 
    ++$cursor; 
}

sub dag_recurse(\@$$);		# { }
sub dag_recurse(\@$$) {
    local(*DIR); 
    my $dirsref = shift;
    my $dir = shift;
    my $level = shift;

    if ( opendir( DIR, $dir ) ) {
	my ($file,$full); 
	while ( defined ($file = readdir(DIR)) ) { 
	    next if ( $file eq '.' || $file eq '..' );
	    $full = File::Spec->catfile( $dir, $file );
	    if ( -d $full ) { 
		dag_recurse( @{$dirsref}, $full, $level+1 );
	    } elsif ( $file =~ /\.dag\.dagman\.out/ ) { 
		push( @{ $dirsref->[$level] }, $full );
	    }
	}
	closedir DIR;
    } else {
	warn "Warning: Unable to open $dir: $!, ignoring\n";
    }
}

sub getsubdagfromdag(\@$$) {
    my $dirsref = shift;
    my $dag = shift;
    my $level = shift;
    
    if ( open( F, "<$dag" ) ) {
	my @subdags = (); 
	while ( <F> ) { 
	    push( @subdags, $1 )
		if /^SUBDAG EXTERNAL \S+ (\S+\.dag)($| DIR)/; 
	}
	close F; 

	foreach my $s ( @subdags ) { 
	    my $dagman = $s . '.dagman.out';
	    push( @{$dirsref->[$level]}, $dagman )
		if ( -e $dagman && -f _ && -r _ && ! -z _ ); 
	}
    } else {
	warn "Warning: open $dag: $!, ignoring\n"; 
    }
}

sub process_tab(@) { 
    my @keys = split /\s+/, shift(); 
    shift;			# unused 
    my @vals = split /\s+/, shift(); 

    my @result = (); 
    my $state = 0; 
    my $total = 0; 
    for ( my $i=0; $i < @keys; ++$i ) { 
	++$state if lc($keys[$i]) eq 'done'; 
	next unless $state; 
	# keep ordering by using an array (that is convertible into a hash).
	# however, remove any punctuation stuff from keys
	$keys[$i] =~ s/[^[:alnum:]]//g;
	push( @result, lc($keys[$i]) => $vals[$i] ); 
	$total += $vals[$i]; 
    }

    ( @result, 'total', $total ); 
}

my $re1 = qr{\*\scondor_scheduniv_exec\.([0-9.]+)\s\(CONDOR_DAGMAN\)\sSTARTING\sUP};
my $re2 = qr{\*\scondor_scheduniv_exec\.([0-9.]+)\s\(condor_DAGMAN\)\spid\s\d+\sEXITING\sWITH\sSTATUS\s(\S+)}; 

sub long_status($$) {
    my $run = shift;
    my $dagfn = shift;

    my @dirs = (); 
    dag_recurse(@dirs,$run,0);
    getsubdagfromdag( @dirs, File::Spec->catfile($run,$dagfn), 1 ); 

    my $dolen = length( '.dagman.out' ); 
    my @result = (); 
    foreach my $d ( reverse @dirs ) { 
	next unless defined $d;
	foreach my $fn ( @{$d} ) {
	    my @tab = (); 
	    my ($start,$final,$pid,$status);
	    if ( open( F, "<$fn" ) ) { 
		while ( <F> ) {
		    ($start,$final) = ($1,"") if /$re1/o;
		    $pid=$1 if /\*\*\sPID\s=\s(\d+)/;
		    ($final,$status) = ($1,$2) if /$re2/o;
		    if ( index($_,'Done') > 0 ) {
			$tab[0] = $_; 
			$tab[1] = <F>;
			$tab[2] = <F>;
		    }
		}
		close F; 
	    } else {
		warn "Warning: open $fn: $!\n";
	    }

	    @tab = process_tab(@tab); 
	    my $short = ( $fn =~ /^$run/o ? 
			  substr( $fn, length($run)+1, -$dolen ) :
			  substr( $fn, 0, -$dolen ) );

	    my $state = 0; 	# unknown -> (U)nsubmitted
	    if ( $start ne $final ) {
		warn "Debug: $start != $final\n" if $main::debug; 
		if ( kill( 0, $pid ) ) { 
		    $state = 2;	# running
		} else {
		    $state = 1; # undeterminable -> (I)dle
		}
	    } else {
		# finished: success (3) or failure (4)
		$state = ( $status == 0 ? 3 : 4 );
	    }

	    push( @result, { name => $short
			   , state => $state
			   , status => $status # may be undef
			   , detail => [ @tab ] 
		           } ); 
			     
	}
    }

    @result;
}

sub dag_summary(\@) {
    my $dref = shift;

    my %result = ( _state => [ map { 0 } @main::dstat ]
		 , _total => 0 ); 
    foreach my $dag ( @{$dref} ) { 
	my $x = $dag->{detail}; 
	for ( my $i=0; $i<@{$x}; $i += 2 ) { 
	    $result{ $x->[$i] } += $x->[$i+1];
	}
	$result{'_state'}[$dag->{state}]++; 
	$result{'_total'}++; 
    }

    %result; 
}

#
# --- main -------------------------------------------------
#
binmode( STDOUT, ':utf8' ) if $main::isutf8;

# parse CLI options
my $heldinfo = 1; 
my $heavy = 0; 
my $noidle = 0; 
my $expert = 0; 
my $legend = 1; 
my $dagsum = 1; 
my ($watch);
GetOptions( 'help|h' => \&usage
	  , 'user|u=s' => \$main::user
	  , 'debug|d+' => \$main::debug
	  , 'verbose|v+' => \$expert
	  , 'version|V' => \&version
	  , 'idle|i!' => \$noidle
	  , 'legend!' => \$legend
	  , 'hold|held!' => \$heldinfo
	  , 'heavy!' => \$heavy
	  , 'ligo|l!' => \$dagsum
	  , 'watch|w:i' => sub {
	      if ( ! $main::onatty ) {
		  warn "FATAL: --watch requires a terminal for output\n"; 
		  exit 42; 
	      } else {
		  unless ( defined &TIOCGWINSZ ) { 
		      warn( "Info: Your Perl installation is incomplete. Your sysadmin could\n", 
			    "run h2ph with proper args to create sys/ioctl.ph and friends.\n" ); 
		      sleep(3); 
		  }
	      }
	      #$watch = $_[1] || 30; # 30s or 60s will be 'production'
	      $watch = $_[1] || 5; 
	  }
	  , 'cache=s' => \$main::cache
	  , 'color' => sub { $main::onatty = 1 }
	  );

# react to changes in terminal size
$SIG{WINCH} = \&sigwinch if ( defined &TIOCGWINSZ && $main::onatty );

# experts don't need spaces :-P
$main::space = ' ' if $expert; 

# determine UTF-8 capabilities
if ( $main::onatty && $main::isutf8 ) { 
    # Draw UTF-8 graphics 
    # Warning: These are the unicode script string that require 'use utf8;'
    if ( $heavy ) { 
	@main::graph = ( " ┣━", " ┗━", " ┃ " );
    } else {
	@main::graph = ( " ├─", " └─", " │ " );
    }
} else {
    # Assume ASCII graphics
    @main::graph = ( ' |-', ' \_', ' | ' ); 
}

# Default $rundir to cwd if nothing was specified
my $run = @ARGV ? abs_path(shift()) : getcwd();
my %braindb = slurp_braindb($run); 
undef $run unless scalar keys %braindb; 
# POST-condition: $run is defined if it is a valid rundir
# FIXME: Extend to permit multiple rundirs a la @ARGV

# what level of expertise (output, verbose mode). Eventually a CLI
# option will permit to use your own mix-n-match output (TBD).  
my @title = @{ $main::title[$expert] }; 

for ( my $cursor=1; ; $cursor=1 ) { 
    my (%count,%job,%dag,@result,@dag) = (); 

    # collect information from condor_q
    condor_q( %job, %dag, @title,
	      noidle => $noidle, 
	      count => \%count );

    # %main::seen is for sanity checks
    %main::seen = map { $_ => 1 } keys %job;

    # collect data to show into @q
    my %leaves = find_leaves(%dag); 
    my @q = (); 
    foreach my $id ( sort { $a <=> $b } keys %leaves ) {
	push( @q, assemble_dag( \%job, \%dag, $id ) ); 
    }

    # collect data from $rundir (if applicable)
    @dag = long_status( $run, $braindb{dag} ) if defined $run; 

    # empty screen and print "Ctrl+C" and date header
    my $reserve = 5; 
    if ( defined $watch ) { 
	($rows,$cols) = initialize_winch(); 
	print "\033[2J\033[H";
	$main::time = CORE::time(); 
	my $now = scalar localtime($main::time); 
	my $msg = 'Press Ctrl+C to exit'; 
	printf "$msg%*s\n\n", $cols-length($msg), $now; 
	$cursor += 2; 

	# too simplistic 'reservations'
	my $nd = @dag;
	if ( $nd ) { 
	    $nd += ( @dag > 1 ? 2 : 1 );
	}
	$reserve += $nd;
    }

    # Are there are Condor jobs in the Q
    if ( @q > 0 ) { 
	# create data to actually show from potentially larger set
	@result = whittle_down( @title, @q ); 

	# determine dynamic column widths
	my @max = column_widths( @title, @result ); 
	
	# print legend (requested by Ewa)
	$cursor = print_qlegend( $cursor, @title ) if $legend;

	# print headers
	print $main::bold if $main::onatty; 
	for ( my $i=0; $i<@max; ++$i ) {
	    print $main::space if $i; 
	    printf "%*s", $max[$i], $title{ $title[$i] }{header}; 
	}
	print $main::reset if $main::onatty; 
	print "\n";
	++$cursor; 
	
	# print each row of results
	for ( my $i=0; $i<@result; ++$i ) { 
	    my $jobstatus = $q[$i]->{jobstatus}; 

	    # decide on color for row and print data columns
	    print $main::ccolor[$jobstatus] if $main::onatty;
	    for ( my $j=0; $j<@{$result[$i]}; ++$j ) {
		print $main::space if $j;
		printf "%*s", $max[$j], $result[$i][$j]; 
	    }

	    # HELD jobs get a separate line with the hold reason
	    if ( $heldinfo && $jobstatus == 5 ) {
		my $tile = $main::graph[1]; 
		print "\n", $tile, fit( $cols-length($tile), $q[$i]{holdreason} );
		++$cursor;
	    }
	    print $main::reset if $main::onatty;

	    # transient trickery for debug mode
	    $cursor = print_qdebug( $cursor, $reserve, $watch, %{$q[$i]} )
		if $main::debug; 

	    # terminate current line
	    print "\n"; 
	    ++$cursor;

	    # skip rest of output if reaching bottom of current terminal 
	    if ( $watch && @result > $rows-$reserve && $cursor > $rows-$reserve ) {
		print "(", plural( @result-$i, 'additional job' );
		print " omitted.)\n";
		++$cursor; 
		last;
	    }
	}

	# create summaries from %count
	$cursor = print_qsummary( $cursor, %count ); 
    } else {
	# nothing in Q
	print "(no matching jobs found in Condor Q)\n"; 
	++$cursor;
    }

    # are we sane? 
    warn "\n(Debug: I appear to be missing some jobs)\n" 
	if ( scalar %main::seen );

    if ( @q > 0 && @dag > 0 ) {
	# separate the two sections
	print "\n";
	++$cursor; 
    }

    # Is there state in the rundir (is there a rundir)? 
    if ( @dag > 0 ) { 
	# determine summary of all workflow jobs
	my %totals = dag_summary( @dag ); 

	# assemble headers
	my $x = $dag[0]{detail};
	my @header = (); 
	my @max = (); 
	for ( my $i=0; $i < @{$x}; $i += 2 ) {
	    push( @header, $x->[$i] ); 
	    push( @max, length($x->[$i]) ); 
	}
	push( @header, 'S' );
	push( @max, 1 ); 
	push( @header, 'WORKFLOW' );
	push( @max, -8 ); 

	# print headers
	print $main::bold if $main::onatty; 
	for ( my $i=0; $i < @header; ++$i ) {
	    print ' ' if $i; 
	    printf "%*s", $max[$i], uc $header[$i];
	}
	print $main::reset if $main::onatty; 
	print "\n";
	++$cursor; 

	# print data
	foreach my $dag ( @dag ) { 
	    # color this row according to state
	    print $main::dcolor[ $dag->{state} ] if $main::onatty;

	    my $x = $dag->{detail}; 
	    for ( my $i=0; $i < @{$x}; $i += 2 ) {
		print ' ' if $i; 
		printf "%*s", $max[$i/2], commas($x->[$i+1]); 
	    }
	    print ' ', $main::dstat[ $dag->{state} ]; 
	    print ' ', fit( 40, $dag->{name} );

	    print $main::reset if $main::onatty; 
	    print "\n";
	    ++$cursor; 
	}

	# print summary
	if ( @dag > 1 ) {
	    for ( my $i=0; $i < @{$dag[0]{detail}}; $i += 2 ) {
		my $k = $dag[0]{detail}[$i]; 
		print ' ' if $i;
		printf "%*s", $max[$i/2], commas($totals{$k}); 
	    }
	    print '  ';
	    print ' TOTALS';

	    print "\n";
	    ++$cursor; 
	}

	print "Workflow summary: ", plural( $totals{'_total'}, 'workflow' ), " total";
	if ( $totals{'_total'} > 0 ) { 
	    my $f = 0; 
	    for ( my $i=0; $i < @main::dstat; ++$i ) { 
		my $x = $totals{_state}; 
		if ( $x->[$i] > 0 ) { 
		    print ( ++$f == 1 ? ' (' : ' ' );
		    print $main::dcolor[$i] if $main::onatty;
		    print $main::dstat[$i], ':', commas($x->[$i]);
		    print $main::reset if $main::onatty; 
		}
	    }
	    print ")" if $f; 
	}

	print "\n"; 
	++$cursor; 
    }


    # are we in 'watch' mode, or is this it? 
    if ( defined $watch ) { 
	sleep($watch);
    } else { 
	last;
    }
}

exit 0;
